# 0496. 下一个更大元素 I Next Greater Element I

[问题描述](https://leetcode.cn/problems/next-greater-element-i)

## 暴力法

思路比较简单:

- 遍历 nums1 数组中的所有元素, 当前元素为 x
- 遍历 nums2 数组中的所有元素, 找到第一个与 x 相等的元素, 然后向右继续遍历, 找到第一个比 x 大的元素

这个算法的时间复杂度是 O(n^2).

算法实现如下:

```rust
{{#include src/main.rs:7:38}}
```

## 单调栈

因为要在 nums2 数组中找到当前元素, 以及当前元素右侧第一个更大的元素, 这个比较符合单调栈的操作.

具体操作是:

- 先遍历数组 nums2, 构造单调递增栈; 同时创建一个哈稀表, 用于存储 `(当前元素值, 当前元素右侧第一个大的元素值)` 映射关系
  `map`
    - 如果当前元素比栈顶元素小, 直接入栈
    - 否则说明当前元素比栈顶元素大, 依次将栈顶元素出栈, 并存入 `map` 中. 这个栈顶元素的右侧第一个大的元素值就是当前元素
- 之后遍历 nums1 数组, 从 `map` 哈稀表中找到对应的更大的元素, 如果没有的话, 就存储为 `-1`

算法实现如下:

```rust
{{#include src/main.rs:5:6}}
{{#include src/main.rs:40:70}}
```

C++ 实现如下:

```cpp
{{#include main.cpp:5:}}
```